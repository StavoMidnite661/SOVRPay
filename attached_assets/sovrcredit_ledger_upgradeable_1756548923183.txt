// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * SOVR Credit Ledger — Upgradeable (Transparent Proxy compatible)
 * ---------------------------------------------------------------
 * Purpose: immutable audit & payout intent source of truth for token → USD rails.
 * - ERC20 credit token (mint/burn)
 * - USD unit‑of‑account capture at redemption time (oracle or fixed peg)
 * - Payout lifecycle events for off‑chain adapters (ACH, Coinbase, Tango, etc.)
 * - Idempotency via SRN (Settlement Reference Number)
 * - Access‑controlled (Treasurer executes, RailExecutor settles), Pausable, Reentrancy‑guarded
 * - No constructor; use initialize(...) for proxies
 */

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

interface AggregatorV3Interface {
    function decimals() external view returns (uint8);
    function latestRoundData() external view returns (
        uint80 roundId,
        int256 answer,
        uint256 startedAt,
        uint256 updatedAt,
        uint80 answeredInRound
    );
}

contract SOVRCreditLedgerUpgradeable is Initializable,
                                         ERC20Upgradeable,
                                         AccessControlUpgradeable,
                                         PausableUpgradeable,
                                         ReentrancyGuardUpgradeable {
    using Strings for uint256;

    // ------------------------ Roles ------------------------
    bytes32 public constant TREASURER_ROLE      = keccak256("TREASURER_ROLE");
    bytes32 public constant RAIL_EXECUTOR_ROLE  = keccak256("RAIL_EXECUTOR_ROLE");
    bytes32 public constant AUDITOR_ROLE        = keccak256("AUDITOR_ROLE");

    // ------------------------ Oracle ------------------------
    AggregatorV3Interface public priceOracle;  // USD per token OR 1e8 fixed for $1 peg
    bool public oracleRequired;                // if false, treat answer as 1.00 USD (fixed peg)

    // ------------------------ Payout model ------------------------
    enum PayoutStatus { None, Requested, Submitted, Settled, Failed }

    struct Payout {
        address initiator;           // msg.sender that called burnForRedemption (treasurer)
        address from;                // token holder whose balance burned
        address beneficiary;         // off‑chain payout recipient
        uint256 amountTokens;        // tokens burned
        uint256 amountUsdCents;      // unit of account captured at time of request (integer cents)
        bytes32 rail;                // e.g., bytes32("ACH"), bytes32("COINBASE"), bytes32("TANGO")
        bytes32 srn;                 // idempotency key
        uint80  oracleRoundId;       // proof of pricing source
        int256  oracleAnswer;        // raw oracle answer
        uint8   oracleDecimals;      // oracle decimals
        uint256 oracleTimestamp;     // last updated timestamp
        PayoutStatus status;         // lifecycle status
        bytes32 adapterRef;          // bank trace, api id, etc.
        uint256 settlementTime;      // block timestamp when settled
        string  evidenceURI;         // optional off‑chain evidence (S3/IPFS URL)
    }

    mapping(bytes32 => Payout) private _payouts; // invoiceId => payout
    mapping(bytes32 => bool)   public  usedSrn;  // SRN idempotency guard

    // ------------------------ Events ------------------------
    event OracleUpdated(address indexed oracle, bool required);

    event PayoutRequested(
        bytes32 indexed invoiceId,
        address indexed from,
        address indexed beneficiary,
        uint256 amountTokens,
        uint256 amountUsdCents,
        bytes32 rail,
        bytes32 srn,
        uint80  oracleRoundId,
        int256  oracleAnswer,
        uint8   oracleDecimals,
        uint256 oracleTimestamp,
        string  evidenceURI
    );

    event PayoutSubmitted(bytes32 indexed invoiceId, bytes32 adapterRef, string evidenceURI);
    event PayoutSettled(bytes32 indexed invoiceId, bytes32 adapterRef, uint256 settlementTime, string evidenceURI);
    event PayoutFailed(bytes32 indexed invoiceId, string reason, string evidenceURI);

    // ------------------------ Initializer ------------------------
    function initialize(
        string memory name_,
        string memory symbol_,
        address admin,
        address treasurer,
        address railExecutor,
        address auditor,
        address oracle,
        bool requireOracle
    ) public initializer {
        __ERC20_init(name_, symbol_);
        __AccessControl_init();
        __Pausable_init();
        __ReentrancyGuard_init();

        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(TREASURER_ROLE, treasurer);
        _grantRole(RAIL_EXECUTOR_ROLE, railExecutor);
        _grantRole(AUDITOR_ROLE, auditor);

        _setOracle(oracle, requireOracle);
    }

    // ------------------------ Admin/Config ------------------------
    function setOracle(address oracle, bool requireOracle) external onlyRole(DEFAULT_ADMIN_ROLE) {
        _setOracle(oracle, requireOracle);
    }

    function _setOracle(address oracle, bool requireOracle) internal {
        priceOracle = AggregatorV3Interface(oracle);
        oracleRequired = requireOracle;
        emit OracleUpdated(oracle, requireOracle);
    }

    function pause() external onlyRole(DEFAULT_ADMIN_ROLE) { _pause(); }
    function unpause() external onlyRole(DEFAULT_ADMIN_ROLE) { _unpause(); }

    // ------------------------ Mint / Burn (Treasury controlled) ------------------------
    function mint(address to, uint256 amount) external whenNotPaused onlyRole(TREASURER_ROLE) {
        _mint(to, amount);
    }

    /**
     * Burn tokens from `from` (requires allowance if caller != from) and record
     * payout intent in USD cents for a specific rail. Emits PayoutRequested.
     * invoiceId: unique per Woo order / invoice
     * srn: settlement reference number (idempotency key)
     */
    function burnForRedemption(
        address from,
        address beneficiary,
        uint256 amountTokens,
        uint256 amountUsdCents,
        bytes32 rail,
        bytes32 invoiceId,
        bytes32 srn,
        string calldata evidenceURI
    ) external whenNotPaused nonReentrant onlyRole(TREASURER_ROLE) {
        require(invoiceId != bytes32(0), "invoiceId req");
        require(!usedSrn[srn], "SRN used");
        require(_payouts[invoiceId].status == PayoutStatus.None, "invoice exists");
        require(amountTokens > 0, "amountTokens=0");
        require(amountUsdCents > 0, "amountUsd=0");

        if (from != _msgSender()) {
            _spendAllowance(from, _msgSender(), amountTokens);
        }
        _burn(from, amountTokens);

        // Capture oracle proof (optional fixed peg)
        uint80 roundId; int256 answer; uint256 updatedAt; uint8 decs;
        if (oracleRequired) {
            require(address(priceOracle) != address(0), "oracle missing");
            (roundId, answer, , updatedAt, ) = priceOracle.latestRoundData();
            decs = priceOracle.decimals();
        } else {
            roundId = 0; answer = int256(1e8); updatedAt = block.timestamp; decs = 8; // treat as $1.00
        }

        Payout storage p = _payouts[invoiceId];
        p.initiator = _msgSender();
        p.from = from;
        p.beneficiary = beneficiary;
        p.amountTokens = amountTokens;
        p.amountUsdCents = amountUsdCents;
        p.rail = rail;
        p.srn = srn;
        p.oracleRoundId = roundId;
        p.oracleAnswer = answer;
        p.oracleDecimals = decs;
        p.oracleTimestamp = updatedAt;
        p.status = PayoutStatus.Requested;
        p.evidenceURI = evidenceURI;

        usedSrn[srn] = true;

        emit PayoutRequested(
            invoiceId,
            from,
            beneficiary,
            amountTokens,
            amountUsdCents,
            rail,
            srn,
            roundId,
            answer,
            decs,
            updatedAt,
            evidenceURI
        );
    }

    // Called by the off‑chain rail adapter when the payout is submitted to a rail
    function markPayoutSubmitted(bytes32 invoiceId, bytes32 adapterRef, string calldata evidenceURI)
        external whenNotPaused onlyRole(RAIL_EXECUTOR_ROLE)
    {
        Payout storage p = _payouts[invoiceId];
        require(p.status == PayoutStatus.Requested, "bad state");
        p.status = PayoutStatus.Submitted;
        p.adapterRef = adapterRef;
        if (bytes(evidenceURI).length > 0) p.evidenceURI = evidenceURI;
        emit PayoutSubmitted(invoiceId, adapterRef, p.evidenceURI);
    }

    // Called by the off‑chain rail adapter upon settlement confirmation
    function markPayoutSettled(bytes32 invoiceId, bytes32 adapterRef, string calldata evidenceURI)
        external whenNotPaused onlyRole(RAIL_EXECUTOR_ROLE)
    {
        Payout storage p = _payouts[invoiceId];
        require(p.status == PayoutStatus.Submitted || p.status == PayoutStatus.Requested, "bad state");
        p.status = PayoutStatus.Settled;
        p.adapterRef = adapterRef;
        p.settlementTime = block.timestamp;
        if (bytes(evidenceURI).length > 0) p.evidenceURI = evidenceURI;
        emit PayoutSettled(invoiceId, adapterRef, p.settlementTime, p.evidenceURI);
    }

    // Called by the rail adapter when payout fails; reason is human‑readable
    function markPayoutFailed(bytes32 invoiceId, string calldata reason, string calldata evidenceURI)
        external whenNotPaused onlyRole(RAIL_EXECUTOR_ROLE)
    {
        Payout storage p = _payouts[invoiceId];
        require(p.status == PayoutStatus.Requested || p.status == PayoutStatus.Submitted, "bad state");
        p.status = PayoutStatus.Failed;
        if (bytes(evidenceURI).length > 0) p.evidenceURI = evidenceURI;
        emit PayoutFailed(invoiceId, reason, p.evidenceURI);
    }

    // ------------------------ Views ------------------------
    function getPayout(bytes32 invoiceId) external view returns (Payout memory) {
        return _payouts[invoiceId];
    }

    function version() external pure returns (string memory) { return "SOVRCL v1.0.0"; }
}
