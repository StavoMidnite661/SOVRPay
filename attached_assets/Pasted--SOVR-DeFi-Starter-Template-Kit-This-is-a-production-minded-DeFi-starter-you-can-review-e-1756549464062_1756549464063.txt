# SOVR DeFi Starter ‚Äì Template Kit

This is a **production‚Äëminded DeFi starter** you can review, extend, and ship. It includes:

- ERC20 governance token with votes
- Single‚Äëasset staking (vault) paying rewards per second
- Timelock + Governor (DAO‚Äëready)
- Treasury + emergency pause/guardian
- Linear token vesting for team/partners
- Minimal oracle interface + pricing guard hooks
- Hardhat project with scripts & tests
- Next.js/Wagmi UI stub for Stake/Unstake/Claim

> Solidity: `^0.8.24`, OpenZeppelin `^5.x`

---

## üìÅ Monorepo Layout

```
/defi-starter
‚îú‚îÄ contracts/
‚îÇ  ‚îú‚îÄ token/
‚îÇ  ‚îÇ  ‚îî‚îÄ SOVRToken.sol
‚îÇ  ‚îú‚îÄ staking/
‚îÇ  ‚îÇ  ‚îî‚îÄ MasterVault.sol
‚îÇ  ‚îú‚îÄ governance/
‚îÇ  ‚îÇ  ‚îú‚îÄ Timelock.sol
‚îÇ  ‚îÇ  ‚îî‚îÄ SOVRGovernor.sol
‚îÇ  ‚îú‚îÄ treasury/
‚îÇ  ‚îÇ  ‚îî‚îÄ Treasury.sol
‚îÇ  ‚îú‚îÄ vesting/
‚îÇ  ‚îÇ  ‚îî‚îÄ LinearVesting.sol
‚îÇ  ‚îú‚îÄ oracle/
‚îÇ  ‚îÇ  ‚îî‚îÄ IPriceOracle.sol
‚îÇ  ‚îî‚îÄ utils/
‚îÇ     ‚îî‚îÄ Addresses.sol
‚îú‚îÄ script/
‚îÇ  ‚îú‚îÄ 00_deploy_core.ts
‚îÇ  ‚îú‚îÄ 01_init_vault.ts
‚îÇ  ‚îî‚îÄ 02_seed_demo.ts
‚îú‚îÄ test/
‚îÇ  ‚îú‚îÄ token.spec.ts
‚îÇ  ‚îú‚îÄ vault.spec.ts
‚îÇ  ‚îî‚îÄ governance.spec.ts
‚îú‚îÄ hardhat.config.ts
‚îú‚îÄ package.json
‚îî‚îÄ app-ui/ (Next.js 14)
   ‚îú‚îÄ app/page.tsx
   ‚îú‚îÄ lib/contracts.ts
   ‚îî‚îÄ components/StakePanel.tsx
```

---

## contracts/token/SOVRToken.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";
import {ERC20Votes} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";

/// @title SOVRToken ‚Äì Governance token with Votes & controlled minting
contract SOVRToken is ERC20, ERC20Permit, ERC20Votes, AccessControl {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(address admin) ERC20("SOVR", "SOVR") ERC20Permit("SOVR") {
        _grantRole(DEFAULT_ADMIN_ROLE, admin);
        _grantRole(MINTER_ROLE, admin);
        _mint(admin, 1_000_000 ether); // boot supply for testing
    }

    function mint(address to, uint256 amount) external onlyRole(MINTER_ROLE) {
        _mint(to, amount);
    }

    // OZ hooks resolution
    function _update(address from, address to, uint256 value) internal override(ERC20, ERC20Votes) {
        super._update(from, to, value);
    }

    function nonces(address owner)
        public
        view
        override(ERC20Permit)
        returns (uint256)
    {
        return super.nonces(owner);
    }
}
```

---

## contracts/staking/MasterVault.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";
import {Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";

/// @title MasterVault ‚Äì single‚Äëasset staking with reward per second
contract MasterVault is ReentrancyGuard, Pausable, Ownable2Step {
    using SafeERC20 for IERC20;

    struct UserInfo {
        uint128 amount; // staked
        uint128 rewardDebt; // rewards accounted
    }

    IERC20 public immutable stakeToken; // token users stake (e.g., SOVR)
    IERC20 public immutable rewardToken; // token paid out as reward

    uint128 public rewardPerSecond; // emissions
    uint64 public lastUpdate; // last accrual timestamp
    uint64 public startTime; // emissions start

    uint256 public accRewardPerShare; // scaled by 1e12
    uint256 public constant ACC_PRECISION = 1e12;

    mapping(address => UserInfo) public users;
    uint256 public totalStaked;

    address public guardian; // can pause

    event Deposit(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event Harvest(address indexed user, uint256 amount);
    event UpdateEmissions(uint256 rewardPerSecond);
    event GuardianSet(address indexed guardian);

    constructor(
        address _owner,
        IERC20 _stakeToken,
        IERC20 _rewardToken,
        uint128 _rewardPerSecond,
        uint64 _startTime
    ) {
        stakeToken = _stakeToken;
        rewardToken = _rewardToken;
        rewardPerSecond = _rewardPerSecond;
        startTime = _startTime;
        lastUpdate = _startTime;
        _transferOwnership(_owner);
    }

    modifier onlyGuardian() {
        require(msg.sender == guardian || msg.sender == owner(), "not guardian");
        _;
    }

    function setGuardian(address g) external onlyOwner { guardian = g; emit GuardianSet(g); }

    function pause() external onlyGuardian { _pause(); }
    function unpause() external onlyOwner { _unpause(); }

    function _updatePool() internal {
        if (block.timestamp <= lastUpdate || block.timestamp < startTime) return;
        if (totalStaked == 0) { lastUpdate = uint64(block.timestamp); return; }
        uint256 timeDelta = block.timestamp - uint256(lastUpdate);
        uint256 reward = timeDelta * uint256(rewardPerSecond);
        accRewardPerShare += (reward * ACC_PRECISION) / totalStaked;
        lastUpdate = uint64(block.timestamp);
    }

    function pendingRewards(address user) public view returns (uint256) {
        UserInfo memory u = users[user];
        uint256 _acc = accRewardPerShare;
        if (block.timestamp > lastUpdate && totalStaked != 0 && block.timestamp >= startTime) {
            uint256 timeDelta = block.timestamp - uint256(lastUpdate);
            uint256 reward = timeDelta * uint256(rewardPerSecond);
            _acc += (reward * ACC_PRECISION) / totalStaked;
        }
        return (uint256(u.amount) * _acc) / ACC_PRECISION - u.rewardDebt;
    }

    function deposit(uint256 amount) external nonReentrant whenNotPaused {
        require(block.timestamp >= startTime, "not started");
        _updatePool();
        UserInfo storage u = users[msg.sender];
        if (u.amount > 0) {
            uint256 pending = (uint256(u.amount) * accRewardPerShare) / ACC_PRECISION - u.rewardDebt;
            if (pending > 0) rewardToken.safeTransfer(msg.sender, pending);
            emit Harvest(msg.sender, pending);
        }
        if (amount > 0) {
            stakeToken.safeTransferFrom(msg.sender, address(this), amount);
            u.amount += uint128(amount);
            totalStaked += amount;
            emit Deposit(msg.sender, amount);
        }
        u.rewardDebt = uint128((uint256(u.amount) * accRewardPerShare) / ACC_PRECISION);
    }

    function withdraw(uint256 amount) external nonReentrant {
        _updatePool();
        UserInfo storage u = users[msg.sender];
        require(amount <= u.amount, "exceeds");
        uint256 pending = (uint256(u.amount) * accRewardPerShare) / ACC_PRECISION - u.rewardDebt;
        if (pending > 0) rewardToken.safeTransfer(msg.sender, pending);
        emit Harvest(msg.sender, pending);
        if (amount > 0) {
            u.amount -= uint128(amount);
            totalStaked -= amount;
            stakeToken.safeTransfer(msg.sender, amount);
            emit Withdraw(msg.sender, amount);
        }
        u.rewardDebt = uint128((uint256(u.amount) * accRewardPerShare) / ACC_PRECISION);
    }

    function updateEmissions(uint128 _rps) external onlyOwner {
        _updatePool();
        rewardPerSecond = _rps;
        emit UpdateEmissions(_rps);
    }

    function rescueTokens(IERC20 token, uint256 amount, address to) external onlyOwner {
        require(token != stakeToken, "no stake");
        token.safeTransfer(to, amount);
    }
}
```

---

## contracts/governance/Timelock.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import {TimelockController} from "@openzeppelin/contracts/governance/TimelockController.sol";

contract Timelock is TimelockController {
    constructor(
        uint256 minDelay,
        address[] memory proposers,
        address[] memory executors,
        address admin
    ) TimelockController(minDelay, proposers, executors, admin) {}
}
```

## contracts/governance/SOVRGovernor.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;
import {Governor} from "@openzeppelin/contracts/governance/Governor.sol";
import {GovernorSettings} from "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
import {GovernorCountingSimple} from "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
import {GovernorVotes} from "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
import {GovernorTimelockControl} from "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";
import {IVotes} from "@openzeppelin/contracts/governance/utils/IVotes.sol";

contract SOVRGovernor is
    Governor,
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorTimelockControl
{
    constructor(IVotes _token, address timelock)
        Governor("SOVRGovernor")
        GovernorSettings(1 /* 1 block */, 45818 /* ~1 week */, 0)
        GovernorVotes(_token)
        GovernorTimelockControl(TimelockController(payable(timelock)))
    {}

    // The following functions are overrides required by Solidity.
    function state(uint256 proposalId)
        public
        view
        override(Governor, GovernorTimelockControl)
        returns (ProposalState)
    {
        return super.state(proposalId);
    }

    function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description)
        public
        override(Governor)
        returns (uint256)
    {
        return super.propose(targets, values, calldatas, description);
    }

    function _execute(uint256 proposalId, address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
        internal
        override(Governor, GovernorTimelockControl)
    {
        super._execute(proposalId, targets, values, calldatas, descriptionHash);
    }

    function _cancel(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, bytes32 descriptionHash)
        internal
        override(Governor, GovernorTimelockControl)
        returns (uint256)
    {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(Governor, GovernorTimelockControl)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}
```

---

## contracts/treasury/Treasury.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/// @title Treasury ‚Äì holds funds, spends via governor‚Äëscheduled calls
contract Treasury is Ownable2Step {
    using SafeERC20 for IERC20;

    event Spend(address indexed to, address indexed token, uint256 amount, bytes data);

    function spend(address to, address token, uint256 amount, bytes calldata data) external onlyOwner {
        if (token == address(0)) {
            (bool ok, ) = to.call{value: amount}(data);
            require(ok, "ETH transfer failed");
        } else {
            IERC20(token).safeTransfer(to, amount);
            if (data.length > 0) {
                (bool ok, ) = to.call(data);
                require(ok, "call failed");
            }
        }
        emit Spend(to, token, amount, data);
    }

    receive() external payable {}
}
```

---

## contracts/vesting/LinearVesting.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Ownable2Step} from "@openzeppelin/contracts/access/Ownable2Step.sol";

/// @title LinearVesting ‚Äì cliff + linear release, revocable
contract LinearVesting is Ownable2Step {
    using SafeERC20 for IERC20;

    struct Grant { uint128 total; uint128 released; uint64 start; uint32 cliff; uint32 duration; bool revoked; }

    IERC20 public immutable token;
    mapping(address => Grant) public grants;

    event Granted(address indexed to, uint256 amount, uint256 start, uint256 cliff, uint256 duration);
    event Released(address indexed to, uint256 amount);
    event Revoked(address indexed to);

    constructor(IERC20 _token, address owner_) { token = _token; _transferOwnership(owner_); }

    function grant(address to, uint128 amount, uint64 start, uint32 cliff, uint32 duration) external onlyOwner {
        require(grants[to].total == 0, "exists");
        grants[to] = Grant({ total: amount, released: 0, start: start, cliff: cliff, duration: duration, revoked: false });
        token.safeTransferFrom(msg.sender, address(this), amount);
        emit Granted(to, amount, start, cliff, duration);
    }

    function releasable(address to) public view returns (uint256) {
        Grant memory g = grants[to];
        if (g.revoked || block.timestamp < g.start + g.cliff) return 0;
        uint256 elapsed = block.timestamp - g.start;
        if (elapsed >= g.duration) return g.total - g.released;
        return (uint256(g.total) * elapsed) / g.duration - g.released;
    }

    function release() external {
        uint256 amt = releasable(msg.sender);
        require(amt > 0, "nothing");
        grants[msg.sender].released += uint128(amt);
        token.safeTransfer(msg.sender, amt);
        emit Released(msg.sender, amt);
    }

    function revoke(address to) external onlyOwner {
        grants[to].revoked = true; emit Revoked(to);
    }
}
```

---

## contracts/oracle/IPriceOracle.sol

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

interface IPriceOracle {
    /// @notice returns price with 8 decimals (e.g., Chainlink style)
    function latestAnswer(address token) external view returns (int256);
}
```

---

## script/00_deploy_core.ts

```ts
import { ethers } from "hardhat";

async function main() {
  const [deployer] = await ethers.getSigners();

  const Token = await ethers.getContractFactory("SOVRToken");
  const token = await Token.deploy(deployer.address);
  await token.waitForDeployment();

  const Timelock = await ethers.getContractFactory("Timelock");
  const minDelay = 24 * 60 * 60; // 1 day
  const timelock = await Timelock.deploy(minDelay, [deployer.address], [deployer.address], deployer.address);
  await timelock.waitForDeployment();

  const Governor = await ethers.getContractFactory("SOVRGovernor");
  const governor = await Governor.deploy(await token.getAddress(), await timelock.getAddress());
  await governor.waitForDeployment();

  const Treasury = await ethers.getContractFactory("Treasury");
  const treasury = await Treasury.deploy();
  await treasury.waitForDeployment();

  console.log("SOVRToken:", await token.getAddress());
  console.log("Timelock:", await timelock.getAddress());
  console.log("Governor:", await governor.getAddress());
  console.log("Treasury:", await treasury.getAddress());
}

main().catch((e) => { console.error(e); process.exit(1); });
```

---

## script/01_init_vault.ts

```ts
import { ethers } from "hardhat";

async function main() {
  const [deployer] = await ethers.getSigners();

  const tokenAddr = process.env.TOKEN!; // stake & reward for demo
  const Vault = await ethers.getContractFactory("MasterVault");

  const rps = 1n * 10n ** 18n; // 1 token/sec
  const start = BigInt(Math.floor(Date.now() / 1000) + 120);

  const vault = await Vault.deploy(
    deployer.address,
    tokenAddr,
    tokenAddr,
    rps,
    Number(start)
  );
  await vault.waitForDeployment();

  console.log("MasterVault:", await vault.getAddress());
}

main().catch((e) => { console.error(e); process.exit(1); });
```

---

## script/02_seed_demo.ts

```ts
import { ethers } from "hardhat";

async function main() {
  const token = await ethers.getContractAt("SOVRToken", process.env.TOKEN!);
  const vault = await ethers.getContractAt("MasterVault", process.env.VAULT!);
  await (await token.mint(await vault.getAddress(), ethers.parseEther("100000"))).wait();
  console.log("Seeded 100k reward tokens into vault");
}

main().catch((e) => { console.error(e); process.exit(1); });
```

---

## test/token.spec.ts

```ts
import { expect } from "chai";
import { ethers } from "hardhat";

describe("SOVRToken", () => {
  it("mints and transfers", async () => {
    const [admin, user] = await ethers.getSigners();
    const Token = await ethers.getContractFactory("SOVRToken");
    const token = await Token.deploy(admin.address);
    await token.waitForDeployment();

    await (await token.mint(user.address, ethers.parseEther("10"))).wait();
    expect(await token.balanceOf(user.address)).to.equal(ethers.parseEther("10"));
  });
});
```

---

## test/vault.spec.ts

```ts
import { expect } from "chai";
import { ethers } from "hardhat";

describe("MasterVault", () => {
  it("accrues rewards per second", async () => {
    const [owner, alice] = await ethers.getSigners();

    const Token = await ethers.getContractFactory("SOVRToken");
    const token = await Token.deploy(owner.address);
    await token.waitForDeployment();

    const Vault = await ethers.getContractFactory("MasterVault");
    const now = (await ethers.provider.getBlock("latest")).timestamp;
    const vault = await Vault.deploy(
      owner.address,
      await token.getAddress(),
      await token.getAddress(),
      1, // 1 wei/sec
      now
    );
    await vault.waitForDeployment();

    await (await token.mint(alice.address, 1000n)).wait();
    await (await token.connect(alice).approve(await vault.getAddress(), 1000n)).wait();
    await (await vault.connect(alice).deposit(1000n)).wait();

    await ethers.provider.send("evm_increaseTime", [10]);
    await ethers.provider.send("evm_mine", []);

    const pending = await vault.pendingRewards(alice.address);
    expect(pending).to.be.greaterThan(0n);
  });
});
```

---

## test/governance.spec.ts

```ts
import { expect } from "chai";
import { ethers } from "hardhat";

describe("Governance wiring", () => {
  it("deploys governor and timelock", async () => {
    const [admin] = await ethers.getSigners();

    const Token = await ethers.getContractFactory("SOVRToken");
    const token = await Token.deploy(admin.address);
    await token.waitForDeployment();

    const Timelock = await ethers.getContractFactory("Timelock");
    const tl = await Timelock.deploy(1, [admin.address], [admin.address], admin.address);

    const Gov = await ethers.getContractFactory("SOVRGovernor");
    const gov = await Gov.deploy(await token.getAddress(), await tl.getAddress());
    expect(await gov.name()).to.equal("SOVRGovernor");
  });
});
```

---

## hardhat.config.ts

```ts
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.24",
    settings: { optimizer: { enabled: true, runs: 200 } },
  },
  networks: {
    hardhat: {},
    amoy: { url: process.env.AMOY_RPC || "", accounts: [process.env.PRIVATE_KEY!].filter(Boolean) as string[] },
    polygon: { url: process.env.POLYGON_RPC || "", accounts: [process.env.PRIVATE_KEY!].filter(Boolean) as string[] },
  },
};
export default config;
```

---

## package.json

```json
{
  "name": "defi-starter",
  "private": true,
  "scripts": {
    "build": "hardhat compile",
    "test": "hardhat test",
    "deploy:core": "hardhat run script/00_deploy_core.ts --network hardhat",
    "deploy:vault": "hardhat run script/01_init_vault.ts",
    "seed": "hardhat run script/02_seed_demo.ts"
  },
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^5.0.0",
    "hardhat": "^2.22.7",
    "typescript": "^5.3.3"
  }
}
```

---

## app-ui/app/page.tsx (Next.js 14 / App Router)

```tsx
"use client";
import { useEffect, useMemo, useState } from "react";
import { createConfig, http, WagmiProvider, useAccount, useWriteContract, useReadContract } from "wagmi";
import { polygonAmoy } from "wagmi/chains";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import StakePanel from "../components/StakePanel";

const config = createConfig({ chains: [polygonAmoy], transports: { [polygonAmoy.id]: http() } });
const qc = new QueryClient();

export default function Page() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={qc}>
        <main className="min-h-dvh bg-black text-white p-6">
          <h1 className="text-2xl font-bold">SOVR DeFi ‚Äì Vault</h1>
          <StakePanel />
        </main>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

---

## app-ui/components/StakePanel.tsx

```tsx
"use client";
import { useState } from "react";
import { useAccount, useReadContract, useWriteContract } from "wagmi";
import { VAULT_ABI, TOKEN_ABI, ADDRESSES } from "../lib/contracts";
import { parseEther } from "viem";

export default function StakePanel() {
  const { address } = useAccount();
  const [amt, setAmt] = useState("0");

  const { data: pending } = useReadContract({
    abi: VAULT_ABI,
    address: ADDRESSES.VAULT as `0x${string}`,
    functionName: "pendingRewards",
    args: [address ?? "0x0000000000000000000000000000000000000000"],
  });

  const { writeContract, isPending } = useWriteContract();

  const stake = async () => {
    await writeContract({ abi: TOKEN_ABI, address: ADDRESSES.TOKEN as `0x${string}`, functionName: "approve", args: [ADDRESSES.VAULT, parseEther(amt)] });
    await writeContract({ abi: VAULT_ABI, address: ADDRESSES.VAULT as `0x${string}`, functionName: "deposit", args: [parseEther(amt)] });
  };

  const unstake = async () => {
    await writeContract({ abi: VAULT_ABI, address: ADDRESSES.VAULT as `0x${string}`, functionName: "withdraw", args: [parseEther(amt)] });
  };

  const claim = async () => { await writeContract({ abi: VAULT_ABI, address: ADDRESSES.VAULT as `0x${string}`, functionName: "withdraw", args: [0n] }); };

  return (
    <div className="mt-6 grid gap-4 max-w-lg">
      <div className="p-4 rounded-2xl bg-white/5">
        <div className="text-sm opacity-70">Pending</div>
        <div className="text-3xl font-semibold">{String(pending ?? 0n)}</div>
      </div>
      <div className="flex gap-2">
        <input className="flex-1 bg-white/10 p-3 rounded-xl" value={amt} onChange={(e) => setAmt(e.target.value)} placeholder="Amount" />
        <button onClick={stake} className="px-4 py-3 rounded-xl bg-white text-black">Stake</button>
        <button onClick={unstake} className="px-4 py-3 rounded-xl bg-white/20">Unstake</button>
        <button onClick={claim} className="px-4 py-3 rounded-xl bg-white/20">Claim</button>
      </div>
    </div>
  );
}
```

---

## app-ui/lib/contracts.ts

```ts
export const ADDRESSES = {
  TOKEN: process.env.NEXT_PUBLIC_TOKEN_ADDRESS || "0x0000000000000000000000000000000000000000",
  VAULT: process.env.NEXT_PUBLIC_VAULT_ADDRESS || "0x0000000000000000000000000000000000000000",
};

export const TOKEN_ABI = [
  { "type": "function", "name": "approve", "stateMutability": "nonpayable", "inputs": [{"name":"spender","type":"address"},{"name":"amount","type":"uint256"}], "outputs": [] },
  { "type": "function", "name": "balanceOf", "stateMutability": "view", "inputs": [{"name":"owner","type":"address"}], "outputs": [{"type":"uint256"}] }
] as const;

export const VAULT_ABI = [
  { "type": "function", "name": "deposit", "stateMutability": "nonpayable", "inputs": [{"name":"amount","type":"uint256"}], "outputs": [] },
  { "type": "function", "name": "withdraw", "stateMutability": "nonpayable", "inputs": [{"name":"amount","type":"uint256"}], "outputs": [] },
  { "type": "function", "name": "pendingRewards", "stateMutability": "view", "inputs": [{"name":"user","type":"address"}], "outputs": [{"type":"uint256"}] }
] as const;
```

---

## ‚ñ∂Ô∏è Quickstart

```bash
# 1) Install deps
npm i

# 2) Compile & test
npm run build && npm test

# 3) Deploy core (local or Amoy)
AMOY_RPC=... PRIVATE_KEY=... npx hardhat run script/00_deploy_core.ts --network amoy
TOKEN=0x... AMOY_RPC=... PRIVATE_KEY=... npx hardhat run script/01_init_vault.ts --network amoy
TOKEN=0x... VAULT=0x... AMOY_RPC=... PRIVATE_KEY=... npx hardhat run script/02_seed_demo.ts --network amoy

# 4) UI
cd app-ui && npm i wagmi viem @tanstack/react-query next react react-dom
NEXT_PUBLIC_TOKEN_ADDRESS=0x... NEXT_PUBLIC_VAULT_ADDRESS=0x... npm run dev
```

---

## üîê Security Review Checklist (built‚Äëin)

- Reentrancy: guarded (`nonReentrant`) paths on state‚Äëchanging flows
- Pausable guardian: emergency halt on vault
- Reward math: `accRewardPerShare` with 1e12 precision, snapshot before state changes
- Admin surface minimal: emissions + rescue; no arbitrary sweep of stake token
- Governance ready: Timelock + Governor to own Treasury/Vault in prod
- Upgradability: not enabled by default; recommend deploying new vaults instead of proxies
- Testing: accrual, deposit/withdraw invariants, emissions updates
- Audits: integrate Slither, Echidna, Foundry fuzzing before mainnet

---

## üìå Notes & Extensions

- Swap `rewardToken` to a different emission asset (e.g., SOVR ‚Üí ECHO) without touching `stakeToken`.
- Add multiple pools by instantiating more `MasterVault` contracts or extend to a pool array.
- Wire `Treasury` ownership to `Timelock` and schedule emissions updates via proposals.
- Plug `IPriceOracle` in `MasterVault` (guard deposits/withdrawals by price bands or TVL caps).
- Add fees (e.g., perf/withdraw) with care; route to Treasury.
- Consider ERC4626 wrapper for vault compatibility with aggregators.
```}
